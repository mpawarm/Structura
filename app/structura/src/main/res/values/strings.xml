<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">Structura</string>
    <string name="drawer_open">Open navigation drawer</string>
    <string name="drawer_close">Close navigation drawer</string>
    <!-- Landing page -->
    <string name="landing">Welcome</string>
    <string name="landing_body_txt_1">Welcome to Structura!</string>
    <string name="landing_body_txt_2">Tap around and see what interests you.</string>
    <!-- Navigation drawer sections -->
    <string name="title_linked_list">Linked List</string>
    <string name="title_bst">Binary Search Tree</string>
    <string name="title_settings">Settings</string>
    <string name="title_about">About</string>
    <!-- Play buttons -->
    <string name="btn_insert_label">Insert</string>
    <string name="btn_delete_label">Delete</string>
    <string name="btn_search_label">Search</string>
    <!-- Content description -->
    <string name="desc_list_item_icon">Item Icon</string>
    <string name="desc_landing_img">Landing Image</string>
    <string name="desc_example">Example action</string>
    <string name="desc_settings">Settings</string>
    <!-- Tabs -->
    <string name="title_play">Play</string>
    <string name="title_summary">Summary</string>
    <string name="title_quiz">Quiz</string>
    <!-- Dialogs -->
    <string name="dialog_insert_title">Insert node</string>
    <string name="dialog_delete_title">Delete which node?</string>
    <string name="dialog_search_title">Find which node?</string>
    <!-- Errors -->
    <string name="err_no_node_value">No node value entered</string>
    <string name="err_node_not_found">Node %d not found</string>
    <!-- Summaries -->
    <string name="ll_summary_body">
    <![CDATA[
    <p>Linked list is a common data structure used in computer science. There are many kinds of linked lists, but we will discuss singly linked lists (SLL) here.</p>
    <p>In an SLL, each node is composed of a value <em>data</em> and a pointer <em>next</em> to the next node in the sequence. This structure allows for efficient insertion or removal of elements from any position in the sequence.</p>
    <p>SLLs can be used to implement several other common abstract data types, including lists (the abstract data type), stacks, queues, associative arrays (dictionaries), etc.</p>
    <p>Generally, we also store a pointer <em>head</em> which points to the first element of the linked list.</p>
    <p>The SLL supports the following operations:</p>
    <p><strong>Insert:</strong> We insert a new node = (<em>d</em>, <em>null</em>) into an SLL. Here, <em>d</em> is its data value and its <em>next</em> parameter is <em>null</em> at the moment.</p>
    <p>We first make the <em>next</em> pointer of this node to point to the current head, and then the head pointer to point to the new node. This way, we insert the node to the front of the SLL.</p>
    <p><strong>Delete:</strong> We take the node as input whose next node has to be deleted. That way, we just set the value of <em>node.next</em> to <em>node.next.next</em>, and destroy <em>node.next</em>.</p>
    <p><strong>Search:</strong> In order to search the SLL for a value, we start with the head, and loop until the value is found, that is, <em>node.data</em> = <em>value</em>, or return <em>False</em> otherwise.</p>
    <p>In each iteration of the loop, we check if the current node\'s data is equal to the input value, if it is not, we make the current node equal to current <em>node.next</em>.</p>
    ]]>
    </string>
    <string name="bst_summary_body">
    <![CDATA[
    <p>A binary search tree (BST) is a node-based binary tree data structure where each node has a comparable key (and an associated value).</p>
    <p> Each node has no more than two child nodes. The left sub-tree contains only nodes with keys less than the parent node; the right sub-tree contains only nodes with keys greater than the parent node. </p>
    <p>Binary search tree is a fundamental data structure used to construct more abstract data structures such as sets, multisets, and associative arrays.</p>
    <p>A BST supports the following operations:</p>
    <p><strong>Insert:</strong> In order to insert a new node in the tree, its key is first compared with that of the root. </p>
    <p>If its key is less than the root\'s, it is then compared with the key of the root\'s left child. If its key is greater, it is compared with the root\'s right child.</p>
    <p>This process continues, until the new node is compared with a leaf node, and then it is added as this node\'s right or left child, depending on its key.</p>
    <p><strong>Delete:</strong> There are three possible cases to consider:</p>
    <p>Deleting a node with no children: simply remove the node from the tree.</p>
    <p>Deleting a node with one child: remove the node and replace it with its child.</p>
    <p>Deleting a node with two children: call the node to be deleted N. Do not delete N. Instead, choose either its in-order successor node or its in-order predecessor node, R.</p>
    <p>Copy the value of R to N, then recursively call delete on R until reaching one of the first two cases.</p>
    <p><strong>Search:</strong> We begin by examining the root node. If the key equals that of the root, we return the node.</p>
    <p>If the key is less than that of the root, we search the left subtree. Else, we search the right subtree.</p>
    <p>This process is repeated until the key is found or the remaining subtree is null.</p>
    <p>On average, this means that each comparison allows the operations to skip over half of the tree.</p>
    ]]>
    </string>

    <!-- Quiz -->
    <string name="btnSubmit">Submit</string>
</resources>
